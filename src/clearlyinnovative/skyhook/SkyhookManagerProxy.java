/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package clearlyinnovative.skyhook;

import java.util.HashMap;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.util.Log;
import org.appcelerator.titanium.util.TiConfig;

import com.skyhookwireless.wps.*;

// This proxy can be created by calling Skyhook.createExample({message: "hello world"})
@Kroll.proxy(creatableInModule = SkyhookModule.class)
public class SkyhookManagerProxy extends KrollProxy {
	// Standard Debugging variables
	private static final String LCAT = "SkyhookProxy";
	private static final boolean DBG = TiConfig.LOGD;
	private String username;
	private String realm;

	// Constructor
	public SkyhookManagerProxy() {
		super();
	}

	public SkyhookManagerProxy create(KrollDict options) {
		setProperty("username", (String) options.get("username"));
		setProperty("realm", (String) options.get("realm"));
		return this;
	}
	
	// Handle creation options
	@Override
	public void handleCreationDict(KrollDict options) {
		super.handleCreationDict(options);

	}

	// Methods
	@SuppressWarnings("deprecation")
	private KrollFunction getCallback(final KrollDict options, final String name)
			throws Exception {
		if (options.containsKey(name)) {
			return (KrollFunction) options.get(name);
		} else {
			Log.d(LCAT, "Callback not found: " + name);
			throw new Exception("Callback not found: " + name);
		}
	}

	// @Kroll.getProperty
	@Kroll.method(runOnUiThread = true)
	public void skyhookLocation(HashMap args) throws Exception {
		final KrollProxy that = this;

		KrollDict options = new KrollDict(args);
		final KrollFunction successCallback = getCallback(options, "success");
		final KrollFunction cancelCallback = getCallback(options, "error");
		
		username = (String) getProperty("username");
		realm = (String) getProperty("realm");

		Log.d(LCAT, "START WPSLocation");
		// Create the authentication object
		// myAndroidContext must be a Context instance
		XPS xps = new XPS(this.getActivity());
		WPSAuthentication auth = new WPSAuthentication(username,
				realm);

		// Callback object
		WPSLocationCallback callback = new WPSLocationCallback() {
			HashMap<String, String> callbackDict = new HashMap<String, String>();

			// What the application should do after it's done
			public void done() {
				// after done() returns, you can make more WPS calls.
				Log.d(LCAT, "WPSLocation DONE : ");
			}

			// What the application should do if an error occurs
			public WPSContinuation handleError(WPSReturnCode error) {
				// handleWPSError(error); // you'll implement handleWPSError()
				Log.d(LCAT, "error : " + error);

				callbackDict.put("success", "false");
				callbackDict.put("error", error.toString());

				// To retry the location call on error use WPS_CONTINUE,
				// otherwise return WPS_STOP
				cancelCallback.callAsync(that.getKrollObject(), callbackDict);
				
				return WPSContinuation.WPS_STOP;
			}

			// Implements the actions using the location object
			public void handleWPSLocation(WPSLocation location) {

				Log.d(LCAT, "location.getLatitude: " + location.getLatitude());
				Log.d(LCAT, "location.getLongitud: " + location.getLongitude());

				callbackDict.put("success", "true");
				callbackDict.put("streetAddress", location.getStreetAddress()
						+ "");
				callbackDict.put("latitude", location.getLatitude() + "");
				callbackDict.put("longitude", location.getLongitude() + "");

				successCallback.callAsync(that.getKrollObject(), callbackDict);
			}
		};

		// Call the location function with callback
		xps.getLocation(auth,
				WPSStreetAddressLookup.WPS_FULL_STREET_ADDRESS_LOOKUP,
				callback);

	}
	
	@Kroll.method(runOnUiThread = true)
	public void registerUser(HashMap args) throws Exception {
		final KrollProxy that = this;
		
		KrollDict options = new KrollDict(args);
		final KrollFunction successCallback = getCallback(options, "success");
		final KrollFunction cancelCallback = getCallback(options, "error");
		
		username = (String) getProperty("username");
		realm = (String) getProperty("realm");
		
		XPS xps = new XPS(this.getActivity());
		WPSAuthentication auth = new WPSAuthentication(username,
				realm);
		
		RegistrationCallback regCallback = new RegistrationCallback() {
			HashMap<String, String> callbackDict = new HashMap<String, String>();
			public void handleSuccess()
			{
				// Indicates that registration has been successful
				Log.d(LCAT, "Registration Successfull!");
				successCallback.callAsync(that.getKrollObject(), callbackDict);
			}

			public WPSContinuation handleError(final WPSReturnCode error)
			{
				// Indicates that registration has failed, along with the error code.
				// Return continue to keep trying, stop to give up.
				callbackDict.put("success", "false");
				callbackDict.put("error", error.toString());
				
				return WPSContinuation.WPS_CONTINUE;  
			}

			public void done()
			{
				// Indicates that registration is completed.  
				// If you call abort() during registration, done() will be
				// called without either handle method being called.
			}
		};
		xps.registerUser(auth, null, regCallback);
	}
	
	@Kroll.method(runOnUiThread = true)
	public void skyhookIPLocation(HashMap args) throws Exception {
		final KrollProxy that = this;

		KrollDict options = new KrollDict(args);
		final KrollFunction successCallback = getCallback(options, "success");
		final KrollFunction cancelCallback = getCallback(options, "error");
		
		username = (String) getProperty("username");
		realm = (String) getProperty("realm");

		// Create the authentication object
		// myAndroidContext must be a Context instance
		XPS xps = new XPS(this.getActivity());
		WPSAuthentication auth = new WPSAuthentication(username,
				realm);
		
		Log.d(LCAT, "START IPLocation");
		
		// Callback object
		IPLocationCallback callback = new IPLocationCallback() {
			HashMap<String, String> callbackDict = new HashMap<String, String>();

			// What the application should do after it's done
			public void done() {
				// after done() returns, you can make more WPS calls.
				Log.d(LCAT, "IPLocation DONE : ");
			}

			// What the application should do if an error occurs
			public WPSContinuation handleError(WPSReturnCode error) {
				// handleWPSError(error); // you'll implement handleWPSError()
				Log.d(LCAT, "error : " + error);

				callbackDict.put("success", "false");
				callbackDict.put("error", error.toString());

				// To retry the location call on error use WPS_CONTINUE,
				// otherwise return WPS_STOP
				cancelCallback.callAsync(that.getKrollObject(), callbackDict);
				return WPSContinuation.WPS_STOP;
			}

			// Implements the actions using the location object
			public void handleIPLocation(IPLocation location) {

				Log.d(LCAT, "location.getLatitude: " + location.getLatitude());
				Log.d(LCAT, "location.getLongitud: " + location.getLongitude());

				callbackDict.put("success", "true");
				callbackDict.put("streetAddress", location.getStreetAddress()
						+ "");
				callbackDict.put("latitude", location.getLatitude() + "");
				callbackDict.put("longitude", location.getLongitude() + "");

				successCallback.callAsync(that.getKrollObject(), callbackDict);
			}
		};

		// Call the location function with callback
		xps.getIPLocation(auth,
				WPSStreetAddressLookup.WPS_FULL_STREET_ADDRESS_LOOKUP,
				callback);
	}
}